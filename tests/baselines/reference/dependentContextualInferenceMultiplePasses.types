=== tests/cases/compiler/dependentContextualInferenceMultiplePasses.ts ===
declare const f:
>f : <T extends F<T>>(t: T) => T

  <T extends F<T>>(t: T) => T
>t : T

type F<T> =
>F : F<T>

  { a: unknown
>a : unknown

  , b: (a: T["a" & keyof T]) => unknown
>b : (a: T["a" & keyof T]) => unknown
>a : T["a" & keyof T]

  , c: (b: ReturnType<Extract<T["b" & keyof T], (...a: never[]) => unknown>>) => unknown
>c : (b: ReturnType<Extract<T["b" & keyof T], (...a: never[]) => unknown>>) => unknown
>b : ReturnType<Extract<T["b" & keyof T], (...a: never[]) => unknown>>
>a : never[]
  }

f({
>f({  a: ({ value: "a" as "a" }),  b: x => ({ value: x.value  }),  c: x => ({ value: x.value  })}) : { a: { value: "a"; }; b: (x: { value: "a"; }) => { value: "a"; }; c: (x: { value: "a"; }) => { value: "a"; }; }
>f : <T extends F<T>>(t: T) => T
>{  a: ({ value: "a" as "a" }),  b: x => ({ value: x.value  }),  c: x => ({ value: x.value  })} : { a: { value: "a"; }; b: (x: { value: "a"; }) => { value: "a"; }; c: (x: { value: "a"; }) => { value: "a"; }; }

  a: ({ value: "a" as "a" }),
>a : { value: "a"; }
>({ value: "a" as "a" }) : { value: "a"; }
>{ value: "a" as "a" } : { value: "a"; }
>value : "a"
>"a" as "a" : "a"
>"a" : "a"

  b: x => ({ value: x.value  }),
>b : (x: { value: "a"; }) => { value: "a"; }
>x => ({ value: x.value  }) : (x: { value: "a"; }) => { value: "a"; }
>x : { value: "a"; }
>({ value: x.value  }) : { value: "a"; }
>{ value: x.value  } : { value: "a"; }
>value : "a"
>x.value : "a"
>x : { value: "a"; }
>value : "a"

  c: x => ({ value: x.value  })
>c : (x: { value: "a"; }) => { value: "a"; }
>x => ({ value: x.value  }) : (x: { value: "a"; }) => { value: "a"; }
>x : { value: "a"; }
>({ value: x.value  }) : { value: "a"; }
>{ value: x.value  } : { value: "a"; }
>value : "a"
>x.value : "a"
>x : { value: "a"; }
>value : "a"

})

